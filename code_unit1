unit Unit1;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, Grids, StdCtrls, Math;

type

  { TForm1 }

  TForm1 = class(TForm)
    Button1: TButton;
    Edit1: TEdit;
    Edit2: TEdit;
    Edit3: TEdit;
    Label1: TLabel;
    Label2: TLabel;
    Label3: TLabel;
    Label4: TLabel;
    Label5: TLabel;
    StringGrid1: TStringGrid;
    procedure Button1Click(Sender: TObject);
  private

  public

  end;

var
  Form1: TForm1;


implementation

{$R *.lfm}

{ TForm1 }

procedure TForm1.Button1Click(Sender: TObject);
/////////////////////////////////////////////////////////////////////////////////////////////

  procedure steps1;
  var
    Edge, logic, p: pointer;
    y, x, xf, yf, TracerX, TracerY, steps, stepsInString, stepRare,
    stepFrequent, stepFrequentD, stepsBig, StringDivTrunc, StringFinish,
    StringStart, Punctir, Nechto: integer;
    px, py: ^integer;
    Biger, countPix, Ostatok, Ostatok1, CaTanDegP, RazmerX, xRazmerX,
    RazmerY, yRazmerY, bigStep, runTime, steps1: integer;
    CaTanDeg, TanDeg, TracerYDiv, deg, stepsBigD: extended;
    TracBool: boolean;
    //вторичный блок переменных
    StringDiv, StringDiv1: extended;
    znak: integer;
  label
    p1, p2, p3, p4;
  label
    logic1, logic2, logic3, logic4;
  label
    Edge1, Edge2, Edge3, Edge4;

    procedure Vstavka;//процедура вставка
    begin
      stepFrequent := round(CaTanDeg);
      StringDiv := frac(CaTanDeg);

      StringDiv1 := 1 - StringDiv;
      znak := sign(0.5 - StringDiv) * sign(StringDiv);
      if StringDiv > 0.5 then  stepsBig := round(1 / StringDiv1)
      else
        stepsBig := round(1 / StringDiv);
      if StringDiv = 0 then  stepsBig := 1;
      Ostatok1 := 1;
      if CaTanDeg = 1 then
      begin
        znak := 0;
        Ostatok1 := 0;
      end;
      stepRare := stepFrequent + znak;
      bigStep := stepsBig * stepFrequent;//поправил
      if bigStep = 0 then
      begin
        bigStep := stepRare;
        stepRare := 0;

      end;
      if stepsBig>1 then stepsBig:=stepsBig+1;
    end;
    procedure ocantovca;
    var x,y:integer;

    begin
          for x:=1 to RazmerX do begin
           StringGrid1.Cells[x, 0] := IntToStr(x-1);
          end;
          for y:=1 to RazmerY do begin
           StringGrid1.Cells[0, y] := IntToStr(y-1);
          end;
    end;

  begin //begin steps1
    deg := StrToInt(Edit1.Text);
    RazmerX := StrToInt(Edit2.Text);
    RazmerY := StrToInt(Edit3.Text);
    StringGrid1.RowCount := RazmerY + 2;
    { Установка количества строк компонента StringGrid}
    StringGrid1.ColCount := RazmerX + 2;
    ////////////////////////////////////////////////////////////////////////////////
    ocantovca;
    ////////////////////////////////////////////////////////////////////////////////
    TanDeg := Tan(DegToRad(deg));
    {%REGION 'ttt'}
    if TanDeg = 0 then
    begin
      CaTanDeg := RazmerX;
      CaTanDegP := Trunc(CaTanDeg);
      px := @x;
      py := @y;
      StringFinish := 0;
      Ostatok := 0;
      Vstavka;
    end
    else
    begin
      CaTanDeg := 1 / TanDeg;
      if CaTanDeg >= TanDeg then
      begin
        px := @x;
        py := @y;
        Vstavka;
        if CaTanDegP > 28 then CaTanDegP := 27;
      end
      else
      begin
        px := @y;
        py := @x;
        Vstavka;
        if CaTanDegP > 28 then CaTanDegP := 27;
      end;
    end;
    if CaTanDegP = 0 then
    begin
      StringFinish := 0;
      Ostatok := 0;
    end
    else
    begin
      StringDivTrunc := Trunc(RazmerX div CaTanDegP);
      //StringFinish:=28-steps*CaTanDegP;
      Ostatok := 28 - StringDivTrunc * CaTanDegP;

    end;
    Label1.Caption := IntToStr(CaTanDegP);
    Label2.Caption := FloatToStr(StringDiv);
    {%ENDREGION}

    x := RazmerX - 1;
    xRazmerX := x;
    StringStart := x;
    yRazmerY := RazmerY - 1;
    y := 0;
    TracerY := 0;
    TracerX := 0;
    steps := 0;
    logic := @logic1;
    p := @p1;
    Edge := @Edge1;
    steps1 := 0;
    xf := 0;
    yf := y + 1;
    stepFrequentD := stepFrequent;
    stepsBigD := 1 / (stepsBig + 1);
    // для отладки первой фазы--------------------------------------------------------------------------------------------------------
    runTime := gettickcount64;
    repeat ///////////////////////////////////////
      repeat
        asm
                 JMP     logic
        end;
        logic1://пропускаем первую строку
          logic := @logic2;
        goto logic4;
        logic2:
          Edge := @Edge3;
        logic := @logic3;
        logic3:
          TracerY := y - steps1;//расчёт ячейки правого столбца
        TracerX := 0;
        if TracerY < 0 then
        begin
          TracerX := RazmerX - (stepFrequent * y + znak * trunc(y / (stepsBig)));//+Ostatok1
          if TracerX < 0 then TracerX := 0;
          TracerY := 0;
        end;
        logic4:
          //  altHead:=@altHead1;
          steps := stepsBig;
        repeat
          if steps = 0 then
          begin
            Biger := x - stepRare + 1;
            steps := stepsBig;
          end
          else
          begin
            Biger := x - stepFrequent + 1;
          end;
          if Biger < 0 then Biger := 0;
          repeat
            {%REGION 'Engine'}
            xf := x + 1;
            //если раскомментироваnm строки После jmp p  то начнётся вывод данных в таблицу
            asm //////////////////////////////
                     JMP     p
            end;
            p1:
              StringGrid1.Cells[xf, yf] := IntToStr(TracerX) + ',' + IntToStr(TracerY) + ',' + '1';
            //запись правого столбца
            p := @p3;
            goto p4;
            p2:
              StringGrid1.Cells[xf, yf] := IntToStr(xf) + ',' + IntToStr(yf) + ',' + '0';
            //автоматическое забивание координат в местах скоса трассы
            p := @p3;
            goto p4;
            p3:
              StringGrid1.Cells[xf, yf] := IntToStr(xf) + ',' + IntToStr(y) + ',' + '0';
            //автоматическое забивание координат трассы на прямых участках
            p4:
              Dec(x);
            {%ENDREGION}
          until x < Biger;
          asm
                   JMP     Edge
          end;
          Edge1://подсчёт шагов в первой строке - других расчётов для первой строки не требуется и знание этого значения нужно для последней строки
            Inc(steps1);
          goto Edge3;
          Edge2://трассировку начальной ячейки каждого шага последней обрабатываемой строки кроме правого столбца
            Dec(steps1);
          TracerY := y - steps1;
          TracerX := 0;
          if TracerY < 0 then begin
             TracerY := 0;
             TracerX := x- (stepFrequent * y + znak * trunc(y / (stepsBig)))+1;
          end;
          p := @p1;
          goto Edge4;
          Edge3:
            p := @p2;
          Edge4:
            Dec(steps);
        until x < 0;
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Inc(y);
        yf := y + 1;
        p := @p1;
        x := xRazmerX;
      until y > yRazmerY - 1;
      Edge := @Edge2;
    until y > yRazmerY;
    runTime := gettickcount64 - runTime;
    Label5.Caption := IntToStr(runTime);
  end;

begin
  steps1;
end;

end.               
